# 回收站使用说明

## 回收站位置

回收站功能已经在**后端完全实现**，但前端界面需要手动添加。

### 后端API已就绪 ✅

以下API接口已经可以使用：

1. **GET `/mcq_public/bank/deleted`** - 列出回收站中的题目
2. **POST `/mcq_public/bank/restore`** - 恢复题目
3. **POST `/mcq_public/bank/clear_deleted`** - 清空回收站
4. **GET `/mcq_public/bank/deletion_logs`** - 查看删除日志

### 前端界面添加方法

在`AdminView.vue`中，需要添加一个新的Tab页"回收站"。

#### 1. 添加Tab页（在"题库管理"后面）

```vue
<!-- 回收站 -->
<el-tab-pane label="回收站" name="recycle">
  <div class="tab-content">
    <!-- 工具栏 -->
    <div class="action-bar">
      <el-button @click="loadDeletedQuestions" :loading="loadingDeleted" :icon="Refresh">
        刷新
      </el-button>
      <el-button 
        type="success" 
        @click="batchRestore"
        :disabled="selectedDeleted.length === 0"
      >
        批量恢复 ({{ selectedDeleted.length }})
      </el-button>
      <el-button 
        type="danger" 
        @click="clearRecycleBin"
      >
        清空回收站
      </el-button>
      <span class="status-msg">{{ recycleMessage }}</span>
    </div>

    <!-- 回收站列表 -->
    <div v-if="deletedQuestions.length === 0" style="text-align: center; padding: 40px; color: #999;">
      回收站为空
    </div>
    <div v-else class="questions-list">
      <el-card 
        v-for="q in deletedQuestions" 
        :key="q.qid"
        class="question-card"
      >
        <div class="q-header">
          <div style="display: flex; align-items: center; gap: 10px;">
            <el-checkbox 
              v-model="selectedDeleted" 
              :label="q.qid"
            />
            <strong style="color: #999;">{{ q.qid }}</strong>
          </div>
        </div>
        
        <div style="margin: 10px 0;">
          <div><strong>题目：</strong>{{ q.stem }}</div>
          <div class="q-options">
            <div v-for="opt in q.options" :key="opt.label">
              {{ opt.label }}. {{ opt.text }}
            </div>
          </div>
          <div style="margin-top: 8px; color: #666; font-size: 13px;">
            <div><strong>答案：</strong>{{ q.answer }}</div>
            <div><strong>删除时间：</strong>{{ q.deleted_at }}</div>
            <div><strong>删除人：</strong>{{ q.deleted_by }}</div>
          </div>
        </div>

        <div class="q-actions">
          <el-button 
            size="small" 
            type="success"
            @click="restoreQuestion(q.qid)"
            :loading="restoringQuestion[q.qid]"
          >
            恢复
          </el-button>
          <el-button 
            size="small" 
            type="danger"
            @click="permanentDelete(q.qid)"
            :loading="permanentDeleting[q.qid]"
          >
            永久删除
          </el-button>
        </div>
      </el-card>
    </div>
  </div>
</el-tab-pane>
```

#### 2. 添加状态变量（在setup()中）

```typescript
// 回收站相关
const deletedQuestions = ref<Question[]>([])
const selectedDeleted = ref<string[]>([])
const loadingDeleted = ref(false)
const recycleMessage = ref('')
const restoringQuestion = reactive<Record<string, boolean>>({})
const permanentDeleting = reactive<Record<string, boolean>>({})
```

#### 3. 添加函数

```typescript
// 加载回收站
const loadDeletedQuestions = async () => {
  loadingDeleted.value = true
  recycleMessage.value = '加载中...'
  try {
    const resp = await fetch(`${MCQ_BASE_URL}/bank/deleted`, {
      headers: {
        'X-User-Name': store.state.user.username,
        'X-User-Role': userRole.value
      }
    })
    const data = await resp.json()
    if (data?.ok) {
      deletedQuestions.value = (data.items || []).map((it: any): Question => ({
        qid: String(it.id ?? it.qid ?? ''),
        stem: it.stem || '',
        options: normalizeOptions(it.options),
        answer: (it.answer || '').toString().toUpperCase(),
        analysis: it.explain || '',
        status: it.status || 'deleted',
        deleted_at: it.deleted_at || '',
        deleted_by: it.deleted_by || ''
      }))
      recycleMessage.value = `共 ${deletedQuestions.value.length} 个已删除题目`
    } else {
      throw new Error(data?.msg || '加载失败')
    }
  } catch (error: any) {
    recycleMessage.value = '加载失败'
    ElMessage.error('加载回收站失败：' + (error?.message || error))
  } finally {
    loadingDeleted.value = false
  }
}

// 恢复单个题目
const restoreQuestion = async (qid: string) => {
  try {
    restoringQuestion[qid] = true
    const resp = await fetch(`${MCQ_BASE_URL}/bank/restore`, {
      method: 'POST',
      headers: { 
        'Content-Type': 'application/json',
        'X-User-Name': store.state.user.username,
        'X-User-Role': userRole.value
      },
      body: JSON.stringify({ 
        ids: [qid],
        user: store.state.user.username
      })
    })
    const data = await resp.json()
    if (data?.ok) {
      ElMessage.success('恢复成功')
      loadDeletedQuestions()
      loadQuestions()
    } else {
      throw new Error(data?.msg || '恢复失败')
    }
  } catch (error: any) {
    ElMessage.error('恢复失败：' + (error?.message || error))
  } finally {
    restoringQuestion[qid] = false
  }
}

// 批量恢复
const batchRestore = async () => {
  if (selectedDeleted.value.length === 0) return
  try {
    await ElMessageBox.confirm(
      `确认恢复选中的 ${selectedDeleted.value.length} 个题目？`,
      '批量恢复',
      { type: 'info' }
    )
    const resp = await fetch(`${MCQ_BASE_URL}/bank/restore`, {
      method: 'POST',
      headers: { 
        'Content-Type': 'application/json',
        'X-User-Name': store.state.user.username,
        'X-User-Role': userRole.value
      },
      body: JSON.stringify({ 
        ids: selectedDeleted.value,
        user: store.state.user.username
      })
    })
    const data = await resp.json()
    if (data?.ok) {
      ElMessage.success(`已恢复 ${data.count} 个题目`)
      selectedDeleted.value = []
      loadDeletedQuestions()
      loadQuestions()
    } else {
      throw new Error(data?.msg || '恢复失败')
    }
  } catch (error: any) {
    if (error !== 'cancel') {
      ElMessage.error('批量恢复失败：' + (error?.message || error))
    }
  }
}

// 永久删除
const permanentDelete = async (qid: string) => {
  try {
    await ElMessageBox.confirm(
      '确认永久删除该题目？此操作无法恢复！',
      '警告',
      { confirmButtonText: '永久删除', cancelButtonText: '取消', type: 'error' }
    )
    permanentDeleting[qid] = true
    const resp = await fetch(`${MCQ_BASE_URL}/bank/delete`, {
      method: 'POST',
      headers: { 
        'Content-Type': 'application/json',
        'X-User-Name': store.state.user.username,
        'X-User-Role': userRole.value
      },
      body: JSON.stringify({ 
        ids: [qid],
        user: store.state.user.username,
        permanent: true  // 关键：设置为永久删除
      })
    })
    const data = await resp.json()
    if (data?.ok) {
      ElMessage.success('已永久删除')
      loadDeletedQuestions()
    } else {
      throw new Error(data?.msg || '删除失败')
    }
  } catch (error: any) {
    if (error !== 'cancel') {
      ElMessage.error('永久删除失败：' + (error?.message || error))
    }
  } finally {
    permanentDeleting[qid] = false
  }
}

// 清空回收站
const clearRecycleBin = async () => {
  try {
    await ElMessageBox.confirm(
      '确认清空回收站？将永久删除30天前的所有题目！',
      '警告',
      { confirmButtonText: '确定清空', cancelButtonText: '取消', type: 'error' }
    )
    const resp = await fetch(`${MCQ_BASE_URL}/bank/clear_deleted`, {
      method: 'POST',
      headers: { 
        'Content-Type': 'application/json',
        'X-User-Name': store.state.user.username,
        'X-User-Role': userRole.value
      },
      body: JSON.stringify({ 
        user: store.state.user.username,
        days: 30
      })
    })
    const data = await resp.json()
    if (data?.ok) {
      ElMessage.success(`已清理 ${data.count} 个题目`)
      loadDeletedQuestions()
    } else {
      throw new Error(data?.msg || '清空失败')
    }
  } catch (error: any) {
    if (error !== 'cancel') {
      ElMessage.error('清空回收站失败：' + (error?.message || error))
    }
  }
}
```

#### 4. 在return中导出

```typescript
return {
  // ... 其他变量
  deletedQuestions,
  selectedDeleted,
  loadingDeleted,
  recycleMessage,
  restoringQuestion,
  permanentDeleting,
  loadDeletedQuestions,
  restoreQuestion,
  batchRestore,
  permanentDelete,
  clearRecycleBin,
  // ... 其他函数
}
```

## 使用流程

### 1. 删除题目
- 在"题库管理"中点击题目的"删除"按钮
- 题目会被移到回收站（软删除）
- 题目从题库列表中消失

### 2. 查看回收站
- 点击"回收站"Tab页
- 点击"刷新"按钮加载已删除的题目
- 可以看到删除时间和删除人

### 3. 恢复题目
- **单个恢复**：点击题目的"恢复"按钮
- **批量恢复**：勾选多个题目，点击"批量恢复"
- 恢复后题目重新出现在题库中

### 4. 永久删除
- 点击题目的"永久删除"按钮
- 确认后题目将被彻底删除，无法恢复

### 5. 清空回收站
- 点击"清空回收站"按钮
- 将永久删除30天前的所有题目

## 权限要求

所有回收站操作都需要**管理员或超级管理员**权限。

## 数据保护

- **30天保护期**：删除的题目保留30天
- **软删除**：默认删除不会立即丢失数据
- **操作日志**：所有操作都会记录日志
- **批量操作**：支持一次恢复多个题目

## 测试API

可以使用curl测试后端API：

```bash
# 列出回收站
curl http://localhost:5000/mcq_public/bank/deleted \
  -H "X-User-Name: admin" \
  -H "X-User-Role: super_admin"

# 恢复题目
curl -X POST http://localhost:5000/mcq_public/bank/restore \
  -H "Content-Type: application/json" \
  -H "X-User-Name: admin" \
  -H "X-User-Role: super_admin" \
  -d '{"ids": ["qid123"], "user": "admin"}'
```

## 总结

回收站功能的后端已经完全实现，前端只需要按照上述步骤添加UI界面即可使用。这是一个完整的企业级删除管理系统！
