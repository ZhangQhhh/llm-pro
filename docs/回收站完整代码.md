# 回收站完整代码

## 需要添加的函数

在`AdminView.vue`的`setup()`函数中，在`// ========== 回收站相关函数 ==========`后添加以下完整代码：

```typescript
// ========== 回收站相关函数 ==========
const loadDeletedQuestions = async () => {
  loadingDeleted.value = true
  recycleMessage.value = '加载中...'
  try {
    const resp = await fetch(`${MCQ_BASE_URL}/bank/deleted`, {
      headers: {
        'X-User-Name': store.state.user.username,
        'X-User-Role': userRole.value
      }
    })
    const data = await resp.json()
    if (data?.ok) {
      deletedQuestions.value = (data.items || []).map((it: any): Question => ({
        qid: String(it.id ?? it.qid ?? ''),
        stem: it.stem || '',
        options: normalizeOptions(it.options),
        answer: (it.answer || '').toString().toUpperCase(),
        analysis: it.explain || '',
        status: it.status || 'deleted',
        deleted_at: it.deleted_at || '',
        deleted_by: it.deleted_by || ''
      }))
      recycleMessage.value = `共 ${deletedQuestions.value.length} 个已删除题目`
    } else {
      throw new Error(data?.msg || '加载失败')
    }
  } catch (error: any) {
    recycleMessage.value = '加载失败'
    ElMessage.error('加载回收站失败：' + (error?.message || error))
  } finally {
    loadingDeleted.value = false
  }
}

const restoreQuestion = async (qid: string) => {
  try {
    restoringQuestion[qid] = true
    const resp = await fetch(`${MCQ_BASE_URL}/bank/restore`, {
      method: 'POST',
      headers: { 
        'Content-Type': 'application/json',
        'X-User-Name': store.state.user.username,
        'X-User-Role': userRole.value
      },
      body: JSON.stringify({ 
        ids: [qid],
        user: store.state.user.username
      })
    })
    const data = await resp.json()
    if (data?.ok) {
      ElMessage.success('恢复成功')
      loadDeletedQuestions()
      loadQuestions()
    } else {
      throw new Error(data?.msg || '恢复失败')
    }
  } catch (error: any) {
    ElMessage.error('恢复失败：' + (error?.message || error))
  } finally {
    restoringQuestion[qid] = false
  }
}

const batchRestore = async () => {
  if (selectedDeleted.value.length === 0) return
  try {
    await ElMessageBox.confirm(
      `确认恢复选中的 ${selectedDeleted.value.length} 个题目？`,
      '批量恢复',
      { type: 'info' }
    )
    const resp = await fetch(`${MCQ_BASE_URL}/bank/restore`, {
      method: 'POST',
      headers: { 
        'Content-Type': 'application/json',
        'X-User-Name': store.state.user.username,
        'X-User-Role': userRole.value
      },
      body: JSON.stringify({ 
        ids: selectedDeleted.value,
        user: store.state.user.username
      })
    })
    const data = await resp.json()
    if (data?.ok) {
      ElMessage.success(`已恢复 ${data.count} 个题目`)
      selectedDeleted.value = []
      loadDeletedQuestions()
      loadQuestions()
    } else {
      throw new Error(data?.msg || '恢复失败')
    }
  } catch (error: any) {
    if (error !== 'cancel') {
      ElMessage.error('批量恢复失败：' + (error?.message || error))
    }
  }
}

const permanentDelete = async (qid: string) => {
  try {
    await ElMessageBox.confirm(
      '确认永久删除该题目？此操作无法恢复！',
      '警告',
      { confirmButtonText: '永久删除', cancelButtonText: '取消', type: 'error' }
    )
    permanentDeleting[qid] = true
    const resp = await fetch(`${MCQ_BASE_URL}/bank/delete`, {
      method: 'POST',
      headers: { 
        'Content-Type': 'application/json',
        'X-User-Name': store.state.user.username,
        'X-User-Role': userRole.value
      },
      body: JSON.stringify({ 
        ids: [qid],
        user: store.state.user.username,
        permanent: true  // 关键：设置为永久删除
      })
    })
    const data = await resp.json()
    if (data?.ok) {
      ElMessage.success('已永久删除')
      loadDeletedQuestions()
    } else {
      throw new Error(data?.msg || '删除失败')
    }
  } catch (error: any) {
    if (error !== 'cancel') {
      ElMessage.error('永久删除失败：' + (error?.message || error))
    }
  } finally {
    permanentDeleting[qid] = false
  }
}

// ✨ 新增：批量永久删除
const batchPermanentDelete = async () => {
  if (selectedDeleted.value.length === 0) return
  
  try {
    await ElMessageBox.confirm(
      `确认永久删除选中的 ${selectedDeleted.value.length} 个题目？此操作无法恢复！`,
      '批量永久删除',
      {
        confirmButtonText: '确定永久删除',
        cancelButtonText: '取消',
        type: 'error',
        dangerouslyUseHTMLString: true,
        message: `<p>您即将永久删除 <strong style="color: #f56c6c;">${selectedDeleted.value.length}</strong> 个题目</p><p style="color: #e6a23c;">⚠️ 此操作无法撤销，题目将被彻底删除！</p>`
      }
    )
    
    const resp = await fetch(`${MCQ_BASE_URL}/bank/delete`, {
      method: 'POST',
      headers: { 
        'Content-Type': 'application/json',
        'X-User-Name': store.state.user.username,
        'X-User-Role': userRole.value
      },
      body: JSON.stringify({ 
        ids: selectedDeleted.value,
        user: store.state.user.username,
        permanent: true  // 关键：设置为永久删除
      })
    })
    
    const data = await resp.json()
    if (data?.ok) {
      ElMessage.success(`已永久删除 ${data.count} 个题目`)
      selectedDeleted.value = []
      loadDeletedQuestions()
    } else {
      throw new Error(data?.msg || '批量永久删除失败')
    }
  } catch (error: any) {
    if (error !== 'cancel') {
      ElMessage.error('批量永久删除失败：' + (error?.message || error))
    }
  }
}

const clearRecycleBin = async () => {
  try {
    await ElMessageBox.confirm(
      '确认清空回收站？将永久删除30天前的所有题目！',
      '警告',
      { confirmButtonText: '确定清空', cancelButtonText: '取消', type: 'error' }
    )
    const resp = await fetch(`${MCQ_BASE_URL}/bank/clear_deleted`, {
      method: 'POST',
      headers: { 
        'Content-Type': 'application/json',
        'X-User-Name': store.state.user.username,
        'X-User-Role': userRole.value
      },
      body: JSON.stringify({ 
        user: store.state.user.username,
        days: 30
      })
    })
    const data = await resp.json()
    if (data?.ok) {
      ElMessage.success(`已清理 ${data.count} 个题目`)
      loadDeletedQuestions()
    } else {
      throw new Error(data?.msg || '清空失败')
    }
  } catch (error: any) {
    if (error !== 'cancel') {
      ElMessage.error('清空回收站失败：' + (error?.message || error))
    }
  }
}
```

## 在return中导出

在`setup()`函数的`return`语句中添加：

```typescript
return {
  // ... 其他变量和函数
  
  // 回收站相关
  deletedQuestions,
  selectedDeleted,
  loadingDeleted,
  recycleMessage,
  restoringQuestion,
  permanentDeleting,
  loadDeletedQuestions,
  restoreQuestion,
  batchRestore,
  permanentDelete,
  batchPermanentDelete,  // ✨ 新增
  clearRecycleBin,
  
  // ... 其他变量和函数
}
```

## 功能说明

### 软删除 vs 硬删除

#### 1. 软删除（可恢复）
- **题库管理 → 删除按钮**: 题目移到回收站
- **批量删除**: 多个题目移到回收站
- **特点**: 
  - ✅ 可以恢复
  - ✅ 30天保护期
  - ✅ 记录删除时间和删除人

#### 2. 硬删除（永久删除）
- **回收站 → 永久删除按钮**: 单个题目彻底删除
- **回收站 → 批量永久删除**: 多个题目彻底删除
- **回收站 → 清空回收站**: 删除30天前的所有题目
- **特点**:
  - ❌ 无法恢复
  - ⚠️ 彻底删除
  - 🔒 需要二次确认

### 操作流程

```
题库管理
  ↓ 删除
回收站（软删除）
  ├─ 恢复 → 题库管理
  └─ 永久删除 → 彻底删除（无法恢复）
```

### 批量操作对比

| 操作 | 位置 | 类型 | 可恢复 | 确认级别 |
|------|------|------|--------|----------|
| 批量删除 | 题库管理 | 软删除 | ✅ 是 | 普通确认 |
| 批量恢复 | 回收站 | 恢复 | - | 普通确认 |
| 批量永久删除 | 回收站 | 硬删除 | ❌ 否 | 严重警告 |
| 清空回收站 | 回收站 | 硬删除 | ❌ 否 | 严重警告 |

### 安全机制

1. **二次确认**: 永久删除需要确认对话框
2. **警告提示**: 使用红色警告样式
3. **数量显示**: 明确显示将删除的数量
4. **权限控制**: 需要管理员权限
5. **操作日志**: 记录所有删除操作

## 使用示例

### 场景1：误删恢复
```
1. 题库管理 → 选择题目 → 批量删除
2. 回收站 → 找到误删的题目 → 恢复
3. 题目重新出现在题库中
```

### 场景2：彻底清理
```
1. 回收站 → 选择不需要的题目
2. 批量永久删除
3. 确认操作
4. 题目彻底删除
```

### 场景3：定期清理
```
1. 回收站 → 清空回收站（30天前）
2. 确认操作
3. 自动删除30天前的所有题目
```

## 测试清单

- [ ] 单个题目软删除（移到回收站）
- [ ] 批量题目软删除
- [ ] 从回收站恢复单个题目
- [ ] 从回收站批量恢复
- [ ] 单个题目永久删除（硬删除）
- [ ] 批量永久删除（硬删除）
- [ ] 清空回收站（30天前）
- [ ] 永久删除后无法恢复
- [ ] 确认对话框正常显示
- [ ] 权限控制正常工作

## 总结

现在系统支持完整的删除管理：

✅ **软删除**: 题库管理 → 删除 → 回收站（可恢复）  
✅ **硬删除**: 回收站 → 永久删除（无法恢复）  
✅ **批量操作**: 支持批量软删除、批量恢复、批量永久删除  
✅ **安全保护**: 二次确认、警告提示、权限控制  
✅ **操作日志**: 完整记录所有操作  

这是一个企业级的删除管理系统！🎉
