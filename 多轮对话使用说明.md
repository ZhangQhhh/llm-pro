# 多轮对话功能使用说明

## 📋 功能概述

本系统实现了基于**向量数据库的多轮对话**功能，采用**滑动窗口 + 向量召回**的混合策略，提示词统一从 `prompts.json` 加载。

---

## 🎯 核心特性

1. **会话隔离**：每个用户有独立的会话ID，对话历史互不干扰
2. **智能召回**：自动检索相关历史对话，提升上下文理解
3. **滑动窗口**：保留最近N轮对话，避免Token超限
4. **向量存储**：所有对话存入Qdrant，支持长期记忆
5. **知识增强**：每轮对话都结合知识库检索结果
6. **提示词统一管理**：所有提示词在 `prompts.json` 中配置

---

## 🚀 使用方法

### 1. API 接口

#### 多轮对话接口

```http
POST /api/knowledge_chat_conversation
Content-Type: application/json

{
  "question": "用户问题",
  "session_id": "会话ID(可选,不提供则自动创建)",
  "thinking": true,
  "model_id": "qwen3-32b",
  "rerank_top_n": 10,
  "use_insert_block": false
}
```

**返回示例**（SSE流）：
```
SESSION:abc123-session-id
CONTENT:正在进行混合检索...
CONTENT:已找到相关资料，正在生成回答...
CONTENT:根据业务规定...
SOURCE:{"id":1,"fileName":"规定.pdf",...}
DONE:
```

#### 清空会话接口

```http
POST /api/conversation/clear
Content-Type: application/json

{
  "session_id": "要清空的会话ID"
}
```

---

## ⚙️ 配置说明

### 1. `config.py` 配置项

```python
# 对话管理配置
CONVERSATION_COLLECTION = "conversations"  # Qdrant对话集合名
MAX_RECENT_TURNS = 3                       # 保留最近N轮对话
MAX_RELEVANT_TURNS = 2                     # 向量检索相关对话数
```

### 2. `prompts.json` 提示词配置

已添加 `conversation` 部分：

```json
{
  "conversation": {
    "system": {
      "rag_with_history": [
        "你是一名资深边检业务专家。请根据下方提供的业务规定和对话历史，回答用户的业务咨询。",
        "",
        "# 规则",
        "1. 你的回答必须严格依据业务规定。",
        "2. 在回答中引用规定要点时，请在句末用 [来源 N] 标注出处。",
        "3. 如果规定未能覆盖问题，请明确指出\"根据现有规定无法回答此问题\"。",
        "4. 如果用户提到\"它\"、\"这个\"等代词，请结合对话历史理解指代内容。",
        "5. 保持对话的连贯性和上下文理解。"
      ],
      "general_with_history": [
        "你是一名资深边检业务专家。请结合对话历史，回答用户的业务咨询。",
        "",
        "# 规则",
        "1. 如果用户提到\"它\"、\"这个\"、\"那个\"等代词，请结合对话历史理解指代内容。",
        "2. 保持对话的连贯性，如果用户在追问，请基于之前的回答继续解释。",
        "3. 如果问题与之前讨论的内容相关，请主动关联说明。"
      ]
    },
    "context_prefix": {
      "relevant_history": "以下是相关的历史对话，可作为背景参考：\n",
      "recent_history": "以下是最近的对话历史：\n",
      "regulations": "业务规定如下：\n"
    }
  }
}
```

---

## 📦 数据存储结构

### Qdrant 对话集合

**集合名称**: `conversations`

**数据结构**:
```json
{
  "vector": [0.1, 0.2, ...],  // 对话向量
  "payload": {
    "session_id": "会话ID",
    "user_query": "用户问题",
    "assistant_response": "助手回答",
    "timestamp": "2025-01-17T10:30:00",
    "context_docs": ["文件1.pdf", "文件2.docx"]
  }
}
```

---

## 🔄 工作流程

```
用户提问
   ↓
1. 知识库检索（混合检索）
   ↓
2. 向量召回相关历史对话
   ↓
3. 获取最近N轮对话
   ↓
4. 构建 messages 数组:
   - system: 系统提示词（从prompts.json加载）
   - system: 相关历史对话
   - system: 最近对话历史
   - system: 知识库检索结果
   - user: 当前问题
   ↓
5. 调用LLM生成回答
   ↓
6. 存储本轮对话到Qdrant
   ↓
7. 返回回答+来源
```

---

## 🧪 测试示例

### Python 测试脚本

```python
import requests
import json

# 第一轮对话
response1 = requests.post(
    "http://localhost:5000/api/knowledge_chat_conversation",
    json={
        "question": "什么是边检业务？",
        "thinking": False,
        "model_id": "qwen3-32b"
    },
    stream=True
)

session_id = None
for line in response1.iter_lines():
    if line:
        decoded = line.decode('utf-8')
        if decoded.startswith('data: SESSION:'):
            session_id = decoded.split('SESSION:')[1]
            print(f"会话ID: {session_id}")
        elif decoded.startswith('data: CONTENT:'):
            content = decoded.split('CONTENT:')[1]
            print(content, end='')

# 第二轮对话（追问）
response2 = requests.post(
    "http://localhost:5000/api/knowledge_chat_conversation",
    json={
        "question": "它的主要职责是什么？",  # 代词"它"会自动关联上文
        "session_id": session_id,  # 使用同一会话ID
        "thinking": False
    },
    stream=True
)

for line in response2.iter_lines():
    if line:
        decoded = line.decode('utf-8')
        if decoded.startswith('data: CONTENT:'):
            content = decoded.split('CONTENT:')[1]
            print(content, end='')
```

---

## 📊 上下文构建策略

### Messages 数组示例

```json
[
  {
    "role": "system",
    "content": "你是一名资深边检业务专家。请根据业务规定和对话历史，回答用户的业务咨询。..."
  },
  {
    "role": "system",
    "content": "以下是相关的历史对话，可作为背景参考：\n"
  },
  {
    "role": "user",
    "content": "什么是边检？"
  },
  {
    "role": "assistant",
    "content": "边检是指..."
  },
  {
    "role": "system",
    "content": "以下是最近的对话历史：\n"
  },
  {
    "role": "user",
    "content": "边检的职责是什么？"
  },
  {
    "role": "assistant",
    "content": "边检的主要职责包括..."
  },
  {
    "role": "system",
    "content": "业务规定如下：\n### 来源 1 - 规定.pdf:\n> 边检机关负责..."
  },
  {
    "role": "user",
    "content": "具体有哪些权限？"
  }
]
```

---

## ⚠️ 注意事项

### 1. Token 控制

- `MAX_RECENT_TURNS = 3`：保留最近3轮对话
- `MAX_RELEVANT_TURNS = 2`：召回2条相关历史
- 如果对话过长，会自动丢弃较早的历史

### 2. 会话管理

- 会话ID由前端维护，建议存储在浏览器 localStorage
- 不同用户使用不同会话ID，确保隐私隔离
- 定期清理过期会话（需要额外实现）

### 3. 性能优化

- 向量检索限制在单个会话内，避免跨会话干扰
- 对话向量化使用与知识库相同的 embedding 模型
- Qdrant 集合自动创建，无需手动初始化

---

## 🔧 故障排查

### 1. 对话管理器未初始化

**错误**: `对话管理器未初始化`

**解决**: 检查 `app.py` 是否调用了 `knowledge_service.initialize_conversation_manager()`

### 2. Qdrant 连接失败

**错误**: `无法连接到 Qdrant`

**解决**: 
```bash
# 检查 Docker 容器
docker ps | findstr qdrant

# 启动容器
docker start qdrant
```

### 3. 提示词加载失败

**错误**: `找不到提示词`

**解决**: 检查 `prompts.json` 是否包含 `conversation` 配置项

---

## 📝 开发说明

### 扩展对话功能

#### 1. 添加对话摘要

在 `ConversationManager` 中添加：

```python
def summarize_history(self, session_id: str) -> str:
    """生成对话摘要"""
    history = self.get_recent_history(session_id, limit=10)
    # 调用 LLM 生成摘要
    return summary
```

#### 2. 导出对话记录

```python
def export_conversation(self, session_id: str) -> List[Dict]:
    """导出完整对话记录"""
    return self.get_recent_history(session_id, limit=1000)
```

---

## ✅ 完成状态

- [x] 对话管理器实现
- [x] 向量存储集成
- [x] API 路由添加
- [x] 提示词配置
- [x] 会话管理
- [x] 多轮对话处理
- [x] 历史召回
- [x] 上下文构建

---

## 🎉 总结

多轮对话功能已完全集成到您的 RAG 系统中，**所有提示词统一在 `prompts.json` 管理**，支持：

1. ✅ 会话隔离
2. ✅ 向量召回
3. ✅ 滑动窗口
4. ✅ 知识增强
5. ✅ 代词理解
6. ✅ 上下文连贯

可以直接使用新接口 `/api/knowledge_chat_conversation` 进行测试！

